# AICowork 插件开发指南

> 版本：0.1.0
> 最后更新：2026-01-23

---

## 目录

1. [插件系统概述](#插件系统概述)
2. [技能插件开发](#技能插件开发)
3. [MCP 服务器开发](#mcp-服务器开发)
4. [代理插件开发](#代理插件开发)
5. [主题定制](#主题定制)
6. [钩子开发](#钩子开发)
7. [插件测试](#插件测试)
8. [插件发布](#插件发布)

---

## 插件系统概述

### 插件类型

AICowork 支持以下类型的插件：

| 类型 | 说明 | 复杂度 | 适用场景 |
|------|------|--------|----------|
| **技能插件** | 自定义 AI 能力 | ⭐ | 简单的任务自动化 |
| **MCP 服务器** | 扩展工具和数据源 | ⭐⭐⭐ | 集成外部服务 |
| **代理插件** | 创建 AI 角色 | ⭐⭐ | 特定领域的专家 |
| **主题插件** | UI 定制 | ⭐ | 界面美化 |
| **钩子插件** | 事件拦截 | ⭐⭐ | 自动化流程 |

### 插件目录结构

```
~/.claude/                    # 插件根目录
├── skills/                    # 技能插件目录
│   ├── my-skill.md           # 技能文件
│   └── advanced/
│       └── coder.json        # 高级技能
├── plugins/                   # 其他插件目录
│   ├── my-plugin/
│   │   ├── package.json
│   │   ├── index.js
│   │   └── README.md
│   └── theme-dark/
│       ├── theme.css
│       └── manifest.json
└── config.json               # 全局配置
```

---

## 技能插件开发

### 什么是技能？

技能是扩展 AI 能力的**提示词模板**，可以包含**变量占位符**和**执行脚本**。

### 快速开始

#### 创建简单技能

1. 打开技能目录：
```bash
# macOS/Linux
open ~/.claude/skills

# Windows
explorer %USERPROFILE%\.claude\skills
```

2. 创建文件 `hello.md`：
```markdown
---
name: hello
description: 向用户打招呼
tags: [greeting]
---

你好！我是 AI 助手，很高兴为你服务。
```

3. 在 AICowork 中使用：
```
/hello
```

### 技能文件格式

#### Markdown 格式（推荐）

```markdown
---
name: skill-name              # 技能名称（必填，唯一）
description: 技能描述         # 描述（必填）
tags: [tag1, tag2]            # 标签（可选）
---

# 提示词内容

这是技能的实际提示词，支持以下变量：

- {{input}}: 用户输入
- {{context}}: 对话上下文
- {{date}}: 当前日期
- {{time}}: 当前时间

示例：
{{input}}

请根据上述内容提供帮助。
```

#### JSON 格式（高级）

```json
{
  "name": "code-reviewer",
  "description": "代码审查专家",
  "prompt": "请审查以下代码：\n\n{{code}}\n\n重点关注：\n1. 代码风格\n2. 性能问题\n3. 安全漏洞",
  "script": {
    "type": "javascript",
    "content": "console.log('开始代码审查...');"
  },
  "tags": ["code", "review"]
}
```

### 变量系统

#### 内置变量

| 变量 | 说明 | 示例输出 |
|------|------|----------|
| `{{input}}` | 用户输入 | "如何学习 Python" |
| `{{context}}` | 对话上下文 | 完整对话历史 |
| `{{date}}` | 当前日期 | "2026-01-23" |
| `{{time}}` | 当前时间 | "14:30:00" |
| `{{datetime}}` | 日期时间 | "2026-01-23 14:30:00" |
| `{{cwd}}` | 当前目录 | `/path/to/project` |

#### 自定义变量

在调用技能时传递变量：

```
/my-skill --var1="value1" --var2="value2"
```

在提示词中使用：

```markdown
处理以下内容：
- 变量1：{{var1}}
- 变量2：{{var2}}
```

### 脚本执行

#### JavaScript 脚本

```json
{
  "name": "data-processor",
  "description": "数据处理",
  "prompt": "处理数据：{{data}}",
  "script": {
    "type": "javascript",
    "content": "
      // 访问全局变量
      console.log('Input:', global.input);

      // 处理数据
      const processed = JSON.parse(global.input);
      console.log('Processed:', processed);

      // 返回结果
      global.result = JSON.stringify(processed);
    "
  }
}
```

#### Python 脚本

```json
{
  "name": "python-script",
  "description": "Python 脚本示例",
  "prompt": "执行 Python 脚本",
  "script": {
    "type": "python",
    "content": "
# -*- coding: utf-8 -*-
import json
import sys

# 读取输入
input_data = json.loads(sys.stdin.read())

# 处理数据
result = {'processed': True, 'data': input_data}

# 输出结果
print(json.dumps(result))
    "
  }
}
```

### 技能开发示例

#### 示例 1：翻译技能

`translator.md`:
```markdown
---
name: translator
description: 多语言翻译助手
tags: [translation, language]
---

你是专业的翻译助手。请将以下内容翻译成{{target_lang}}：

{{text}}

翻译要求：
1. 保持原文格式
2. 准确传达原意
3. 使用自然的表达
4. 专有名词保留原文
```

使用：
```
/translator --target_lang="English" --text="你好世界"
```

#### 示例 2：代码生成器

`codegen.md`:
```markdown
---
name: codegen
description: 代码生成器
tags: [code, generation]
---

根据以下需求生成{{lang}}代码：

{{requirement}}

要求：
1. 遵循{{lang}}最佳实践
2. 添加必要注释
3. 包含错误处理
4. 提供使用示例

```{{lang}}
// 在此生成代码
```
```

使用：
```
/codegen --lang="python" --requirement="读取CSV文件并计算平均值"
```

#### 示例 3：文档生成器

`doc-generator.json`:
```json
{
  "name": "doc-generator",
  "description": "API 文档生成器",
  "prompt": "根据以下代码生成 API 文档：\n\n```{{lang}}\n{{code}}\n```\n\n生成的文档应包含：\n1. 函数描述\n2. 参数说明\n3. 返回值说明\n4. 使用示例\n5. 注意事项",
  "script": {
    "type": "javascript",
    "content": "
      // 保存生成的文档
      const fs = require('fs');
      const path = require('path');

      // 获取输出目录
      const outputDir = global.outputDir || './docs';

      // 生成文件名
      const filename = `api-${Date.now()}.md`;
      const filepath = path.join(outputDir, filename);

      // 保存文档
      fs.writeFileSync(filepath, global.result, 'utf-8');
      console.log(`文档已保存: ${filepath}`);
    "
  },
  "tags": ["documentation", "code"]
}
```

### 技能调试

#### 查看技能日志

1. 打开开发者工具（`F12`）
2. 切换到 Console 标签
3. 执行技能
4. 查看日志输出

#### 常见问题

**问题**: 技能未出现在列表中
- **解决**: 检查文件是否在 `~/.claude/skills/` 目录
- **解决**: 确认文件格式正确（Markdown 或 JSON）

**问题**: 变量未替换
- **解决**: 确认变量名使用双花括号 `{{varname}}`
- **解决**: 检查变量名是否拼写正确

**问题**: 脚本执行失败
- **解决**: 检查脚本语法是否正确
- **解决**: 查看控制台错误信息
- **解决**: 确认脚本类型（javascript/python）正确

---

## MCP 服务器开发

### 什么是 MCP？

MCP (Model Context Protocol) 是一个**开放协议**，允许 AI 应用访问外部工具和数据源。

### MCP 服务器结构

```
my-mcp-server/
├── package.json           # NPM 包配置
├── tsconfig.json          # TypeScript 配置
├── src/
│   ├── index.ts          # 入口文件
│   ├── tools/            # 工具定义
│   │   ├── my-tool.ts
│   │   └── another-tool.ts
│   └── utils/            # 工具函数
└── README.md             # 说明文档
```

### 快速开始

#### 1. 创建项目

```bash
mkdir my-mcp-server
cd my-mcp-server
npm init -y

# 安装依赖
npm install @modelcontextprotocol/sdk
npm install -D typescript @types/node

# 初始化 TypeScript
npx tsc --init
```

#### 2. 创建服务器

`src/index.ts`:
```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

// 创建服务器实例
const server = new Server(
  {
    name: 'my-mcp-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// 注册工具列表
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'get_weather',
        description: '获取指定城市的天气信息',
        inputSchema: {
          type: 'object',
          properties: {
            city: {
              type: 'string',
              description: '城市名称',
            },
          },
          required: ['city'],
        },
      },
      {
        name: 'calculate',
        description: '执行数学计算',
        inputSchema: {
          type: 'object',
          properties: {
            expression: {
              type: 'string',
              description: '数学表达式，如 "2 + 2"',
            },
          },
          required: ['expression'],
        },
      },
    ],
  };
});

// 处理工具调用
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  switch (name) {
    case 'get_weather':
      const city = args.city as string;
      // 调用天气 API
      const weather = await getWeather(city);
      return {
        content: [
          {
            type: 'text',
            text: JSON.stringify(weather, null, 2),
          },
        ],
      };

    case 'calculate':
      const expression = args.expression as string;
      try {
        // 注意：生产环境应使用安全的数学库
        const result = eval(expression);
        return {
          content: [
            {
              type: 'text',
              text: `结果: ${result}`,
            },
          ],
        };
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `计算错误: ${error}`,
            },
          ],
          isError: true,
        };
      }

    default:
      throw new Error(`未知工具: ${name}`);
  }
});

// 启动服务器
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('My MCP Server running on stdio');
}

main().catch(console.error);

// 工具函数
async function getWeather(city: string) {
  // 实际实现中调用真实的天气 API
  return {
    city,
    temperature: 25,
    condition: '晴朗',
    humidity: 60,
  };
}
```

#### 3. 配置编译

`tsconfig.json`:
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```

`package.json`:
```json
{
  "name": "my-mcp-server",
  "version": "1.0.0",
  "type": "module",
  "main": "./dist/index.js",
  "bin": {
    "my-mcp-server": "./dist/index.js"
  },
  "scripts": {
    "build": "tsc",
    "watch": "tsc --watch",
    "prepublishOnly": "npm run build"
  },
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  }
}
```

#### 4. 编译和测试

```bash
# 编译
npm run build

# 测试服务器
echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | node dist/index.js

# 测试工具调用
echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"get_weather","arguments":{"city":"北京"}},"id":1}' | node dist/index.js
```

#### 5. 在 AICowork 中使用

1. 打开 AICowork 设置 → MCP 服务器
2. 添加新配置：
   - **服务器名称**: `my-server`
   - **命令**: `node`
   - **参数**: `/path/to/my-mcp-server/dist/index.js`
3. 保存并启用
4. 测试连接

### 高级功能

#### 资源支持

允许 AI 访问服务器的资源：

```typescript
import { ListResourcesRequestSchema, ReadResourceRequestSchema } from '@modelcontextprotocol/sdk/types.js';

// 注册资源
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: 'file:///config.json',
        name: '配置文件',
        description: '应用配置',
        mimeType: 'application/json',
      },
    ],
  };
});

// 读取资源
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const uri = request.params.uri;
  if (uri === 'file:///config.json') {
    return {
      contents: [
        {
          uri,
          mimeType: 'application/json',
          text: JSON.stringify({ key: 'value' }, null, 2),
        },
      ],
    };
  }
  throw new Error('资源未找到');
});
```

#### 提示词模板

提供自定义提示词：

```typescript
import { ListPromptsRequestSchema, GetPromptRequestSchema } from '@modelcontextprotocol/sdk/types.js';

server.setRequestHandler(ListPromptsRequestSchema, async () => {
  return {
    prompts: [
      {
        name: 'summarize',
        description: '总结文本',
        arguments: [
          {
            name: 'text',
            description: '要总结的文本',
            required: true,
          },
        ],
      },
    ],
  };
});

server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  if (name === 'summarize') {
    return {
      messages: [
        {
          role: 'user',
          content: {
            type: 'text',
            text: `请总结以下内容：\n\n${args.text}`,
          },
        },
      ],
    };
  }
  throw new Error('提示词未找到');
});
```

---

## 代理插件开发

### 什么是代理？

代理（Agent）是具有**特定角色**和**能力**的 AI 助手，可以通过**系统提示词**和**工具权限**定制。

### 创建代理

1. 打开 AICowork 设置 → 代理管理

2. 点击"创建代理"

3. 填写配置：
   - **代理 ID**: `code-reviewer`
   - **名称**: 代码审查专家
   - **描述**: 专注于代码质量和最佳实践
   - **系统提示词**:
   ```
   你是一位资深的代码审查专家。你的职责是：
   1. 检查代码风格和格式
   2. 识别潜在的性能问题
   3. 发现安全隐患
   4. 建议最佳实践
   5. 确保代码可维护性

   审查时请：
   - 使用建设性的语言
   - 提供具体的改进建议
   - 解释为什么需要改进
   - 给出代码示例
   ```
   - **允许工具**: `Read`, `Grep`, `Edit`
   - **温度参数**: `0.3`（低温度，更确定性）

4. 保存代理

### 代理编排

#### 并行模式

多个代理同时工作，适合独立任务：

```json
{
  "mode": "parallel",
  "maxConcurrency": 3,
  "stopOnFailure": false,
  "enableAggregation": true,
  "aggregationStrategy": "all"
}
```

**场景**: 代码审查
- 代理1: 检查代码风格
- 代理2: 检查安全性
- 代理3: 检查性能

#### 顺序模式

代理按顺序执行，后续代理可以使用前面的结果：

```json
{
  "mode": "sequential",
  "agentSequence": ["planner", "coder", "reviewer"]
}
```

**场景**: 软件开发流程
1. planner: 制定计划
2. coder: 编写代码
3. reviewer: 审查代码

#### 动态模式

根据任务动态选择代理：

```json
{
  "mode": "dynamic",
  "maxConcurrency": 2
}
```

### 代理开发示例

#### 示例 1：文档生成代理

```json
{
  "id": "doc-writer",
  "name": "技术文档作家",
  "description": "专注于编写清晰的技术文档",
  "systemPrompt": "你是一位技术文档专家。你的任务是：\n\n1. 理解代码或功能的用途\n2. 编写清晰的文档\n3. 包含使用示例\n4. 使用 Markdown 格式\n\n文档应包含：\n- 功能描述\n- 参数说明\n- 返回值说明\n- 使用示例\n- 注意事项",
  "allowedTools": ["Read", "Grep"],
  "temperature": 0.4
}
```

#### 示例 2：测试工程师代理

```json
{
  "id": "qa-engineer",
  "name": "QA 工程师",
  "description": "专注于测试和质量保证",
  "systemPrompt": "你是一位 QA 工程师。你的职责是：\n\n1. 分析需求和代码\n2. 设计测试用例\n3. 编写测试代码\n4. 发现潜在的 bug\n\n测试类型：\n- 单元测试\n- 集成测试\n- 边界测试\n- 异常处理测试",
  "allowedTools": ["Read", "Write", "Edit", "Bash"],
  "temperature": 0.2
}
```

---

## 主题定制

### 创建主题

1. 打开主题目录：
```bash
# macOS/Linux
open ~/.claude/themes

# Windows
explorer %USERPROFILE%\.claude\themes
```

2. 创建主题文件 `my-theme.css`:
```css
:root {
  /* 颜色变量 */
  --primary-color: #3b82f6;
  --secondary-color: #8b5cf6;
  --background: #0f172a;
  --surface: #1e293b;
  --text: #f1f5f9;
  --text-secondary: #94a3b8;
  --border: #334155;

  /* 字体 */
  --font-family: 'Inter', -apple-system, sans-serif;
  --font-size: 14px;
  --line-height: 1.6;

  /* 间距 */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;

  /* 圆角 */
  --radius-sm: 4px;
  --radius-md: 8px;
  --radius-lg: 12px;
}

/* 消息气泡 */
.message-user {
  background: var(--primary-color);
  color: white;
}

.message-assistant {
  background: var(--surface);
  color: var(--text);
}

/* 输入框 */
.input-area {
  background: var(--surface);
  border: 1px solid var(--border);
}

/* 按钮样式 */
.button-primary {
  background: var(--primary-color);
  color: white;
  border-radius: var(--radius-md);
}

.button-secondary {
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
}
```

3. 在设置中应用主题

### 主题变量参考

| 变量 | 说明 | 默认值 |
|------|------|--------|
| `--primary-color` | 主色调 | `#3b82f6` |
| `--background` | 背景色 | `#ffffff` |
| `--surface` | 表面色 | `#f9fafb` |
| `--text` | 文本色 | `#111827` |
| `--border` | 边框色 | `#e5e7eb` |
| `--font-family` | 字体 | `Inter, sans-serif` |
| `--font-size` | 字号 | `14px` |

---

## 钩子开发

### 什么是钩子？

钩子（Hooks）在**特定事件**前后执行自定义命令，实现自动化。

### 钩子类型

| 类型 | 触发时机 | 用途 |
|------|----------|------|
| `preToolUse` | 工具使用前 | 验证、修改参数 |
| `postToolUse` | 工具使用后 | 日志、通知、后处理 |

### 创建钩子

#### 示例 1：工具使用日志

在设置 → 钩子配置中添加：

```json
{
  "type": "postToolUse",
  "hook": "log-tool-use",
  "command": "echo \"Tool: {{tool}}, Args: {{args}}\" >> ~/.claude/tool-usage.log",
  "description": "记录所有工具使用情况"
}
```

#### 示例 2：文件修改通知

```json
{
  "type": "postToolUse",
  "hook": "notify-write",
  "command": "if [ '{{tool}}' = 'Write' ]; then notify-send '文件已修改' '{{args.file_path}}'; fi",
  "description": "文件修改时显示桌面通知"
}
```

#### 示例 3：代码格式化

```json
{
  "type": "preToolUse",
  "hook": "format-before-write",
  "command": "if [ '{{tool}}' = 'Edit' ]; then prettier --write '{{args.file_path}}' 2>/dev/null || true; fi",
  "description": "编辑前自动格式化代码"
}
```

### 钩子变量

| 变量 | 说明 |
|------|------|
| `{{tool}}` | 工具名称 |
| `{{args}}` | 工具参数（JSON） |
| `{{result}}` | 工具结果（postToolUse） |
| `{{timestamp}}` | 时间戳 |
| `{{cwd}}` | 当前目录 |

---

## 插件测试

### 技能测试

```
1. 在 AICowork 中加载技能
2. 执行技能
3. 检查输出是否符合预期
4. 测试边界情况
```

### MCP 服务器测试

```bash
# 单元测试
npm test

# 集成测试
echo '{"jsonrpc":"2.0","method":"tools/list","id":1}' | node dist/index.js

# 在 AICowork 中测试连接
```

### 代理测试

```
1. 创建测试会话
2. 调用代理
3. 检查响应质量
4. 调整温度参数
```

---

## 插件发布

### 发布技能

1. 在 GitHub 创建仓库
2. 添加 `README.md` 说明文档
3. 在技能社区分享

### 发布 MCP 服务器

1. 发布到 NPM：
```bash
npm publish
```

2. 创建安装说明

3. 在 MCP 服务器列表注册

### 发布主题

1. 截图预览
2. 上传到主题仓库
3. 分享链接

---

**最后更新：2026-01-23**
**维护者：AICowork 开发团队**
